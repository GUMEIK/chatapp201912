# 登录页面   /



登录页面输入用户名，
- 将用户名写入cookie
- 将用户名写入store
- 发送套接字为con的 socket 请求
```js
socket.emit("con", {
            username: userName
});
```
服务端收到con请求，返回userData请求
将socket.id 与用户名进行绑定，然后返回客户端所有连接的用户

# 好友列表界面   mailList页面
- 渲染所有连接到服务器的用户，生成好友列表
    - 点击好友列表，获取该列表的用户名(将该用户名写入cookie 和 store)
    - 发送con请求
    - 发送 privateChatData 请求，在服务端生成数组来储存对话消息记录
    - 点击好友列表跳转到对话框，传递用户数据，渲染对话框
- 从cookie 中读取用户名

# 对话框页面
- 发送privateChatData请求
- 发送 con 请求
- 监听 receiveMessage ，渲染页面
- 发送 chat message 请求



```
登录页面


点击登录按钮
- 发送con 请求，将用户名与当前socket.id绑定，服务器返回上线的所有用户 userData

- 设置用户名字到cookie
- 设置用户名到store


进入好友列表界面



在componentDidMount生命周期函数中：
- con 请求，请求内容为空，目的是为了拿到当前上线的所有用户，以便于刷新好友列表
- 监听userData(服务器端返回的数据)，渲染页面，每条列表含有上线用户的 用户名等信息

列表点击事件
- 获取当前用户要联系的目标对象(存入cookie和store)
- 发送con 请求，……
- 发送 privateChatData 请求，用于储存消息记录
- 跳转到对话框页面，并传递发送者和接受者数据


进入对话框页面

组件 componentDidMount 生命周期
- 取到发送者和接受者数据(从cookie中取)
- 发送privateChatData请求，是为了防止刷新页面，发送者和接受者信息丢失(防止仅仅通过点击的方式发送这个privateChatData请求)
- 发送con 请求，一方面是为了将用户用当前socket.id 实时绑定 ，另一方面是为了获取用户的最新信息
- 监听 receiveMessage 请求，该请求会带有会话信息，拿到数据后渲染页面
- 发送 chat message 请求：该请求会向对方传递会话数据


发送按钮事件
- 发送 chat message 请求，该请求会处理消息发送相关内容


修改：
登录页面只是将当前登录用户信息写入cookie,不再发送con请求，在通讯录界面读取cookie，在生命周期函数中发送con请求，这就解决了登录上去会有两个相同的好友列表的情况



问题：在对话框界面，刷新，会导致消息记录消失，原因是因为  被对话者数据丢失

这是因为在生命周期函数中重新设置了cookie导致的

被对话者的信息，可以直接从cookie中读取，这样就可以解决刷新导致数据丢失的问题



问题：发消息时，会将该消息发给好友列表中的所有人

```